[gd_resource type="ShaderMaterial" load_steps=3 format=3 uid="uid://c6perjtd8jr4l"]

[ext_resource type="CompressedTexture2DArray" uid="uid://cj8k35d124enw" path="res://art/tilemap.png" id="1_06fay"]

[sub_resource type="Shader" id="Shader_c04dw"]
code = "// NOTE: Shader automatically converted from Godot Engine 4.1.stable's StandardMaterial3D.

shader_type spatial;
render_mode blend_mix,cull_disabled,diffuse_lambert,specular_schlick_ggx;
uniform sampler2DArray texture_albedo : source_color,filter_nearest_mipmap_anisotropic,repeat_enable;
global uniform sampler2D distorted_normals : hint_normal,filter_linear_mipmap_anisotropic,repeat_enable;

varying flat int bitmask;
varying flat int index;

void vertex()
{
    vec3 pos = VERTEX.xyz;
    int d = int(CUSTOM0.r * 255.0);
    int a = int(CUSTOM0.g * 255.0);
    int b = int(CUSTOM0.b * 255.0);
    index = (a << 8) | b;
    bitmask = int(CUSTOM0.a * 255.0);
    
    BINORMAL = vec3(0.0, -1.0, 0.0);
    if (d == 0)
    {
        UV = vec2(pos.x, pos.z) + vec2(0.5);
        NORMAL = vec3(0.0, 1.0, 0.0);
        TANGENT = vec3(-1.0, 0.0, 0.0);
        BINORMAL = vec3(0.0, 0.0, 1.0);
    }
    else if (d == 1)
    {
        UV = vec2(-pos.x, pos.z) + vec2(0.5);
        NORMAL = vec3(0.0, -1.0, 0.0);
        TANGENT = vec3(-1.0, 0.0, 0.0);
        BINORMAL = vec3(0.0, 0.0, -1.0);
    }
    else if (d == 2)
    {
        UV = vec2(-pos.x, -pos.y) + vec2(0.5);
        NORMAL = vec3(0.0, 0.0, -1.0);
        TANGENT = vec3(1.0, 0.0, 0.0);
    }
    else if (d == 3)
    {
        UV = vec2(pos.x, -pos.y) + vec2(0.5);
        NORMAL = vec3(0.0, 0.0, 1.0);
        TANGENT = vec3(-1.0, 0.0, 0.0);
    }
    else if (d == 4)
    {
        UV = vec2(pos.z, -pos.y) + vec2(0.5);
        NORMAL = vec3(-1.0, 0.0, 0.0);
        TANGENT = vec3(0.0, 0.0, -1.0);
    }
    else if (d == 5)
    {
        UV = vec2(-pos.z, -pos.y) + vec2(0.5);
        NORMAL = vec3(1.0, 0.0, 0.0);
        TANGENT = vec3(0.0, 0.0, 1.0);
    }
}

#define BIT_00 1
#define BIT_10 2
#define BIT_20 4
#define BIT_01 8
#define BIT_21 16
#define BIT_02 32
#define BIT_12 64
#define BIT_22 128

float fresnelSchlick(float incidence, float f0, float f90)
{
    float t = clamp(1.0 - incidence, 0.0, 1.0);
    float t2 = t*t;
    float t5 = t2*t2*t;
    return mix(f0, f90, t5);
}
vec3 sample_normals(vec2 uv, float x, float y, float scale)
{
    vec3 norm = (texture(distorted_normals, (uv + vec2(x, y)) * scale).rgb * 2.0 - 1.0)*0.21;
    return norm;
}

void fragment()
{
    vec3 norm = sample_normals(UV, TIME*-0.2, TIME*0.4, 0.025) * vec3(vec2(0.2), 1.0);
    norm += sample_normals(UV, TIME*0.1, TIME*0.1, 0.05) * vec3(vec2(0.15), 1.0);
    norm += sample_normals(UV, TIME*0.2, TIME*-0.1, 0.075) * vec3(vec2(0.1), 1.0);
    
    vec2 uv = UV + norm.xy*vec2(2.0, 0.5);
    
    vec2 quadrant = round(fract(uv));
    float offset = 0.0;
    
    bool ud_offset = false;
    bool lr_offset = false;
    bool di_offset = false;
    int ud_test = 0;
    int lr_test = 0;
    int di_test = 0;
    if (quadrant.x < 0.5 && quadrant.y >= 0.5)
    {
        ud_test = BIT_10;
        lr_test = BIT_01;
        di_test = BIT_00;
    }
    else if (quadrant.x >= 0.5 && quadrant.y >= 0.5)
    {
        ud_test = BIT_10;
        lr_test = BIT_21;
        di_test = BIT_20;
    }
    else if (quadrant.x < 0.5 && quadrant.y <0.5)
    {
        ud_test = BIT_12;
        lr_test = BIT_01;
        di_test = BIT_02;
    }
    else if (quadrant.x >= 0.5 && quadrant.y < 0.5)
    {
        ud_test = BIT_12;
        lr_test = BIT_21;
        di_test = BIT_22;
    }
    if ((bitmask & ud_test) == 0)
        ud_offset = true;
    if ((bitmask & lr_test) == 0)
        lr_offset = true;
    if (ud_offset || lr_offset || (bitmask & di_test) == 0)
        di_offset = true;
    
    if (ud_offset && lr_offset)
        offset = 1.0;
    else if (lr_offset)
        offset = 2.0;
    else if (ud_offset)
        offset = 3.0;
    else if (di_offset)
        offset = 4.0;
    
    vec4 tex = texture(texture_albedo, vec3(uv, float(index) + offset));
    vec3 color = tex.rgb;
    
    float brightness = dot(color, vec3(1.0/3.0));
    float color_v = max(0.0, brightness-0.4)*5.0 + 0.5;
    float color_part = color.b*4.0 + color.g*0.5 - color.r*0.5 + 0.5;
    float f = clamp(color_part - color_v, 0.0, 1.0);
    float roughness = 0.05;
    
    ALBEDO = color;
    ROUGHNESS = roughness;
    
    float a = sin(UV.x*4.0);
    
    //norm.x = sin(TIME*5.0 + UV.x*5.0 + a)*0.02*cos(TIME*2.0 + UV.y*1.0 - a*0.5);
    //norm.y = sin(TIME*3.0 + UV.y*5.0 - a)*0.02*sin(TIME*2.0 + UV.x*1.0 - a*0.5);
    //norm.z = 1.5;
    norm = normalize(norm);
    norm = norm;
    
    NORMAL_MAP = norm * 0.5 + 0.5;
    
    //ALBEDO = vec3(1.0);
    //METALLIC = 1.0;
    //ROUGHNESS = 0.0;
    
    vec3 n = NORMAL*norm.z + TANGENT*norm.x + BINORMAL*norm.y;
    
    vec3 view = normalize(VIEW);
    float inc = max(0.0, dot(view, n));
    float fresnel = fresnelSchlick(inc, 0.02, 1.0);
    
    METALLIC = fresnel;
    
    vec3 grey = vec3(dot(ALBEDO, vec3(1.0/3.0)));
    ALBEDO = mix(ALBEDO, grey, fresnel*0.5);
    
    ALPHA = tex.a;
}
"

[resource]
render_priority = 0
shader = SubResource("Shader_c04dw")
shader_parameter/texture_albedo = ExtResource("1_06fay")
