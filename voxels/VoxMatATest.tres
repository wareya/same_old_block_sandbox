[gd_resource type="ShaderMaterial" load_steps=3 format=3 uid="uid://bts2d6ityo6xe"]

[ext_resource type="CompressedTexture2DArray" uid="uid://cj8k35d124enw" path="res://art/tilemap.png" id="1_bute4"]

[sub_resource type="Shader" id="Shader_apfu3"]
code = "// NOTE: Shader automatically converted from Godot Engine 4.1.stable's StandardMaterial3D.

shader_type spatial;
render_mode blend_mix,depth_draw_opaque,cull_back,diffuse_lambert,specular_schlick_ggx;
uniform sampler2DArray texture_albedo : source_color,filter_nearest_mipmap_anisotropic,repeat_enable;

varying flat int bitmask;
varying flat int index;

void vertex()
{
    int d = int(CUSTOM0.r * 255.0);
    int a = int(CUSTOM0.g * 255.0);
    int b = int(CUSTOM0.b * 255.0);
    index = (a << 8) | b;
    bitmask = int(CUSTOM0.a * 255.0);
    
    vec3 orig_vertex = VERTEX;
    
    if (d >= 6)
    {
        int item = VERTEX_ID/4/4;
        item = item ^ (item*12593) ^ 0x10F9BA38;
        float offset_x = float(item%1024)/1024.0;
        float offset_z = float(item/5%1024)/1024.0;
        VERTEX.x += offset_x*0.35;
        VERTEX.z += offset_z*0.35;
    }
    
    vec3 pos = orig_vertex.xyz;
    
    if (d == 0)
    {
        UV = vec2(pos.x, pos.z) + vec2(0.5);
        NORMAL = vec3(0.0, 1.0, 0.0);
    }
    else if (d == 1)
    {
        UV = vec2(-pos.x, pos.z) + vec2(0.5);
        NORMAL = vec3(0.0, -1.0, 0.0);
    }
    else if (d == 2)
    {
        UV = vec2(-pos.x, -pos.y) + vec2(0.5);
        NORMAL = vec3(0.0, 0.0, -1.0);
    }
    else if (d == 3)
    {
        UV = vec2(pos.x, -pos.y) + vec2(0.5);
        NORMAL = vec3(0.0, 0.0, 1.0);
    }
    else if (d == 4)
    {
        UV = vec2(pos.z, -pos.y) + vec2(0.5);
        NORMAL = vec3(-1.0, 0.0, 0.0);
    }
    else if (d == 5)
    {
        UV = vec2(-pos.z, -pos.y) + vec2(0.5);
        NORMAL = vec3(1.0, 0.0, 0.0);
    }
    else // mesh
    {
        pos.x = (fract(pos.x + 0.5) - 0.5) / 0.9;
        UV = vec2(pos.x, -pos.y) + vec2(0.5);
        if (d == 6)
            NORMAL = normalize(vec3( 1.0, 0.0, -1.0));
        else if (d == 7)
            NORMAL = normalize(vec3(-1.0, 0.0, -1.0));
        else if (d == 8)
            NORMAL = normalize(vec3(-1.0, 0.0,  1.0));
        else if (d == 9)
            NORMAL = normalize(vec3( 1.0, 0.0,  1.0));
    }
    
    //float to_bottom
    bool do_sway = (VERTEX_ID/2 % 2) == 0 || d < 6;
    float offset_x = VERTEX.x/2.0;
    float offset_z = VERTEX.z/3.0 + VERTEX.x/4.0;
    float factor = do_sway ? 1.0 : 0.0;
    VERTEX.x += sin(TIME*2.09 + VERTEX.y + offset_x)*0.05*factor;
    VERTEX.z += cos(TIME*2.24 + VERTEX.y + 0.1 - offset_z)*0.05*factor;
}

#define BIT_00 1
#define BIT_10 2
#define BIT_20 4
#define BIT_01 8
#define BIT_21 16
#define BIT_02 32
#define BIT_12 64
#define BIT_22 128

void fragment()
{
    vec2 quadrant = round(fract(UV));
    float offset = 0.0;
    
    bool ud_offset = false;
    bool lr_offset = false;
    bool di_offset = false;
    int ud_test = 0;
    int lr_test = 0;
    int di_test = 0;
    if (quadrant.x < 0.5 && quadrant.y >= 0.5)
    {
        ud_test = BIT_10;
        lr_test = BIT_01;
        di_test = BIT_00;
    }
    else if (quadrant.x >= 0.5 && quadrant.y >= 0.5)
    {
        ud_test = BIT_10;
        lr_test = BIT_21;
        di_test = BIT_20;
    }
    else if (quadrant.x < 0.5 && quadrant.y <0.5)
    {
        ud_test = BIT_12;
        lr_test = BIT_01;
        di_test = BIT_02;
    }
    else if (quadrant.x >= 0.5 && quadrant.y < 0.5)
    {
        ud_test = BIT_12;
        lr_test = BIT_21;
        di_test = BIT_22;
    }
    if ((bitmask & ud_test) == 0)
        ud_offset = true;
    if ((bitmask & lr_test) == 0)
        lr_offset = true;
    if (ud_offset || lr_offset || (bitmask & di_test) == 0)
        di_offset = true;
    
    if (ud_offset && lr_offset)
        offset = 1.0;
    else if (lr_offset)
        offset = 2.0;
    else if (ud_offset)
        offset = 3.0;
    else if (di_offset)
        offset = 4.0;
    
    vec4 tex = texture(texture_albedo, vec3(UV.x, UV.y, float(index) + offset));
    vec3 color = tex.rgb;
    
    float brightness = dot(color, vec3(1.0/3.0));
    float color_v = max(0.0, brightness-0.4)*5.0 + 0.5;
    float color_part = color.b*4.0 + color.g*0.5 - color.r*0.5 + 0.5;
    float f = clamp(color_part - color_v, 0.0, 1.0);
    float roughness = mix(0.5, 1.0, f);
    
    ALBEDO = color;
    ROUGHNESS = roughness;
    
    if (tex.a < 0.5)
        discard;
}
"

[resource]
render_priority = 0
shader = SubResource("Shader_apfu3")
shader_parameter/texture_albedo = ExtResource("1_bute4")
